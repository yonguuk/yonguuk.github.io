<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Trees: Is This a Binary Search Tree? | YongUk</title>
<meta name="generator" content="Jekyll v4.1.0" />
<meta property="og:title" content="Trees: Is This a Binary Search Tree?" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Hackerrank : Trees: Is This a Binary Search Tree?" />
<meta property="og:description" content="Hackerrank : Trees: Is This a Binary Search Tree?" />
<link rel="canonical" href="http://0.0.0.0:4000/algorithms/2020/06/09/is-this-binary-tree.html" />
<meta property="og:url" content="http://0.0.0.0:4000/algorithms/2020/06/09/is-this-binary-tree.html" />
<meta property="og:site_name" content="YongUk" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-09T23:50:18+00:00" />
<script type="application/ld+json">
{"headline":"Trees: Is This a Binary Search Tree?","dateModified":"2020-06-09T23:50:18+00:00","description":"Hackerrank : Trees: Is This a Binary Search Tree?","datePublished":"2020-06-09T23:50:18+00:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/algorithms/2020/06/09/is-this-binary-tree.html"},"url":"http://0.0.0.0:4000/algorithms/2020/06/09/is-this-binary-tree.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://0.0.0.0:4000/feed.xml" title="YongUk" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">YongUk</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Trees: Is This a Binary Search Tree?</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-06-09T23:50:18+00:00" itemprop="datePublished">Jun 9, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><a href="https://www.hackerrank.com/challenges/ctci-is-binary-search-tree/problem?h_l=interview&amp;playlist_slugs%5B%5D=interview-preparation-kit&amp;playlist_slugs%5B%5D=trees">Hackerrank : Trees: Is This a Binary Search Tree?</a></p>

<h3 id="풀이-1-중위-순회-in-order-traversal">풀이 1. 중위 순회 (In-Order Traversal)</h3>

<p>이 방법은 이진 탐색 트리의 특성을 활용하는 방법입니다.</p>

<p><strong>이진 탐색 트리를 중위 순회 하면 원소를 오름차순으로 탐색 할 수 있습니다.</strong>  따라서 이진 탐색 트리 라면, 트리를 중위 순회 하여 값을 리스트에 집어 넣었을 때, 오름차순으로 정렬되어 있어야 합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="nf">checkBST</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">inOrderTraversal</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">nodes</span><span class="o">);</span>
    <span class="k">return</span> <span class="nf">isAscendingOrder</span><span class="o">(</span><span class="n">nodes</span><span class="o">);</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">inOrderTraversal</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">,</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="n">inOrderTraversal</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">nodes</span><span class="o">);</span>
    <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">data</span><span class="o">);</span>
    <span class="n">inOrderTraversal</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">nodes</span><span class="o">);</span>
<span class="o">}</span>

<span class="kt">boolean</span> <span class="nf">isAscendingOrder</span><span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">list</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Java로 제출하려고 보니 원인 모를 에러가 발생하여 Python 코드를 첨부합니다. Discussions을 봐도 같은 문제를 겪는 사람이 많이 있는데 이유는 모르겠네요.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">checkBST</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">inOrderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">isAscendingOrder</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">inOrderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">inOrderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
    <span class="n">nodes</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">inOrderTraversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">isAscendingOrder</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">prev</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<h3 id="시간-복잡도">시간 복잡도</h3>

<p>위 알고리즘은 ‘트리 순회’ 단계와 ‘리스트가 오름차순으로 정렬되어 있는지 확인’ 하는 단계로 나뉘어져 있습니다.</p>

<p>1) 트리 순회</p>

<ul>
  <li>트리를 한 번 순회하는데는 O(n) (n은 노드의 갯수).</li>
</ul>

<p>2) 리스트가 오름차순으로 정렬되어 있는지 확인</p>

<ul>
  <li>리스트를 한 번 순회 하면서 오름차순인지 확인합니다. 리스트의 길이 역시 노드의 갯수와 같기 때문에 O(n).</li>
</ul>

<p>따라서 시간 복잡도는 O(n)이 됩니다.</p>

<h3 id="풀이-2-최댓값-최솟값">풀이 2. 최댓값, 최솟값</h3>

<p>이진 탐색 트리를 만족하는 조건(문제에 나와있는)은 아래와 같습니다.</p>

<ul>
  <li>현재 노드의 왼쪽 서브트리의 모든 노드의 값은 현재 노드 보다 작다.</li>
  <li>현재 노드의 오른쪽 서브트리의 모든 노드의 값은 현재 노드 보다 크다.</li>
  <li>모든 노드의 값은 서로 다르다.</li>
</ul>

<p>root 노드부터 하위 노드를 탐색하면서 해당 노드가 가질 수 있는 최댓값 / 최솟값의 범위를 전달하여 이진 탐색 트리의 조건에 맞는지 확인할 수 있습니다.</p>

<p>아래의 트리를 root 노드부터 왼쪽 서브트리 → 오른쪽 서브트리 순서로 탐색을 한다고 하면,</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>					<span class="mi">3</span>
				<span class="o">/</span>   \
       <span class="mi">2</span>     <span class="mi">5</span>
      <span class="o">/</span>     <span class="o">/</span>  \
     <span class="mi">1</span>     <span class="mi">4</span>    <span class="mi">6</span>
</code></pre></div></div>

<p>1) 노드 ‘2’ 방문</p>

<p>가장 먼저 노드 ‘2’를 방문하게 됩니다. 그럼 이제 해당 노드의 값이 이진 탐색 트리의 규칙에 맞는지 확인 해야 합니다. 노드 ‘2’는 ‘3’의 왼쪽 자식 노드이기 때문에 값이 3보다 작아야 하고, 최솟값의 기준은 없습니다. 조건을 만족하니 다음 노드를 방문합니다.</p>

<p>2) 노드 ‘1’ 방문</p>

<p>노드 ‘1’의 경우 노드 ‘2’의 왼쪽 자식 노드이기 때문에 노드의 값은 2보다 작아야 하고 최솟값의 기준은 없습니다. 따라서 조건을 만족합니다.</p>

<p>3) 노드 ‘5’ 방문</p>

<p>root 노드의 왼쪽 서브트리 방문을 마쳤으니 오른쪽 서브트리 방문을 시작합니다. 처음 방문할 노드는 노드 ‘5’ 입니다. 해당 노드가 가질 수 있는 값의 범위는 어떻게 될까요?</p>

<p>우선 노드 ‘3’의 오른쪽 자식 노드이므로 해당 노드의 값은 3보다 커야 합니다. 오른쪽 자식 노드이므로 최댓값의 제한은 없습니다. 따라서 이진 탐색 트리의 조건을 만족합니다.</p>

<p>4) 노드 ‘4’ 방문</p>

<p>노드 ‘4’는 노드 ‘5’의 왼쪽 자식 노드이므로 값이 5보다 작아야 합니다. 또한 root 노드의 오른쪽 서브트리에 있으므로 3보다 큰 값을 가져야 합니다. 따라서 이진 탐색 트리의 조건을 만족합니다.</p>

<p>5) 노드 ‘6’ 방문</p>

<p>마지막으로 노드 ‘6’을 방문합니다. 노드 ‘5’의 오른쪽 자식 노드이므로 최솟값은 5이고, 최댓값은 제한이 없습니다. 따라서 이진 탐색 트리의 조건을 만족합니다. 이렇게 확인이 끝나고 해당 트리는 이진 탐색 트리의 조건을 만족하는 것을 알 수 있습니다.</p>

<p>위 과정을 정리하면 아래와 같습니다.</p>

<ul>
  <li>왼쪽 자식 노드일 경우
    <ul>
      <li>최댓값 : 부모 노드의 값</li>
      <li>최솟값 : 부모 노드의 최솟값</li>
    </ul>
  </li>
  <li>오른쪽 자식 노드일 경우
    <ul>
      <li>최댓값 : 부모 노드의 최댓값</li>
      <li>최솟값 : 부모 노드의 값</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">checkBST</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="nb">min</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">'-inf'</span><span class="p">);</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">checkBSTHelper</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">checkBSTHelper</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    
    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="nb">min</span> <span class="ow">or</span> <span class="n">node</span><span class="p">.</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="nb">max</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    
    <span class="k">return</span> <span class="n">checkBSTHelper</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> \
							<span class="n">checkBSTHelper</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="시간-복잡도-1">시간 복잡도</h3>

<p>이 코드는 전체 트리의 노드를 한 번 순회하기 때문에 시간 복잡도는 풀이 1과 마찬가지로 O(n) 이 됩니다.</p>

  </div><a class="u-url" href="/algorithms/2020/06/09/is-this-binary-tree.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">YongUk</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">YongUk</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>알고리즘 풀이와 개발 관련 스터디 내용, 기타 리뷰 등</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
